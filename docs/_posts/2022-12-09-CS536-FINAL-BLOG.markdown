---
layout: post
title: "Validating and Evaluating the Paper, \"Implementing AES Encryption on Programmable Switches via Scrambled Lookup\""
date: 2022-12-09 07:36:00 -0000
categories: 
---

![Purdue CS Logo](https://github.com/Winston-Wang-01/Winston-Wang-01.github.io/blob/gh-pages/purdue-cs-logo.jpg?raw=true)

# Reproducing "Implementing AES Encryption on Programmable Switches via Scrambled Lookup Tables"

**Members:** [Rui Zhu](zhu1054@purdue.edu), [Siyu Yao](yao269@purdue.edu), [Byounguk Min]( min87@purdue.edu), [Walter Yarrow](wyarrow@purdue.edu), [Winston Wang](wang4362@purdue.edu)

## Project Statement

For this project we sought to extend the results of ["Implementing AES Encryption on Programmable Switches via Scrambled Lookup Tables"](https://www.cs.princeton.edu/~xiaoqic/documents/paper-P4AES-SPIN20.pdf) by Xiaoqi Chen using multiple mininet hosts and multiple ONOS switches utilizing programmed with p4 for encryption and decryption. While the original paper only supported a one way encryption between two hosts and one switch, we aimed to extend our implementation to more complex topologies while also supporting decryption.

## Advanced Encryption Standard

First, some quick background information on AES. Advanced Encryption Standard (AES) is a symmetric-key encryption algorithm specified by the U.S. National Institute of Standards and Technology since 2001. Built on the idea of substituion-permutation networks, AES encrypts data block by block into equivalent sized ciphertext using repeated rounds of encryption. Data block size and key size can both be varied, with the standard variants being AES-128, AES-192, and AES-256, respectively.

While a successful AES implementation in the data plane would be helpful for a number of security annd privacy applications, the nature of the algorithm's round by round, block by block encryption strategy makes implementation on standard programmable switches a difficult task for such devices with limited processing power when even AES-128 requires 10 rounds of encryption.

The key insight of "Implementing AES Encryption on Programmable Switches via Scrambled Lookup Tables", then, was the utilization of Scrambled Lookup Tables to take advantage of table-matching to reduce the number of arithmetic operations required for encryption.

See the video below for more details on what we did:

  <iframe width="100%" height="500" src="https://user-images.githubusercontent.com/54554850/206820592-9539976f-6244-45ae-8c9f-3cb065afaa5c.mp4"
          ></iframe>



## Our Implementation and Results

Our implementation was run on an AWS EC2 instance with 2vCPU and 8 gb of of memory, and utilizes a 2 switch, 6 host Mininet topology heavily drawing upon the assignment 3 code repository with custom Scapy scripts for packet generation and for collecting metrics such as packect rate to measure encryption overhead.

We evaluated our version of the AES algorithm using Mininet, and investigated the performance differences between AES encrypted networks and networks without AES encryption, and determined the overhead of the encryption process. It can be considered as a network with two segments: one segment is formed with one switch and three hosts, and another segment is formed with one switch and three hosts on the other side. The goal of our implementation is to be able to forward encrypted packets between hosts. See below for our findings:

![AES Result](https://github.com/Winston-Wang-01/Winston-Wang-01.github.io/blob/gh-pages/docs/_posts/graph.png?raw=true)

You can see the rather significant degradation in performance, likely due to high memory usage, despite our utilization of the match action table optimization and reduction of the number of rounds in the AES encryption algorithm. Unfortunately, with no unoptimized AES encryption strategy implemented, it's hard to see the concrete impact of the paper's optimizations here, which reflects a bit of bad experiment design on our part. The fact that these are virtual switches on not actual hardware likely doesn't help either.

### Conclusion
That about wraps it up for our attempt to reproduce the results from the paper "Implementing AES Encryption on Programmable Switches via Scrambled Lookup Tables". We implemented and evaluated a P4 program on Mininet in order to demonstrate the real overhead of adding AES encryption onto the programmable switch, but due to time and debugging constraints were unable to successfully implement decryption in time. Ultimately, our team learned a lot about the difficulties behind making concrete implementations of theoretical flows we've learned about, as well as core project management lessons like regular meetings and workload distribution.

## Source Code Repository: 
If you'd like to take a look at our implementation, the source code link can be found below. The README.md file should contain information on how to run it yourself :)

[https://github.com/ByungUkMin/p4-encryption/](https://github.com/ByungUkMin/p4-encryption/)


